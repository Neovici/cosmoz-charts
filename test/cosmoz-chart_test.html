<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

		<title>cosmoz-charts test</title>

		<script src="/components/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
		<script src="/components/@polymer/test-fixture/test-fixture.js?nocompile"></script>
		<script src="/components/mocha/mocha.js?nocompile"></script>
		<script src="/components/chai/chai.js?nocompile"></script>
		<script src="/components/wct-mocha/wct-mocha.js?nocompile"></script>
		<script src="/components/sinon/pkg/sinon.js?nocompile"></script>
		<script src="/components/sinon-chai/lib/sinon-chai.js?nocompile"></script>

		<link rel="stylesheet" href="/components/billboard.js/dist/billboard.css">

		<script type="module" src="../cosmoz-chart.js"></script>
	</head>
	<body>

		<test-fixture id="BasicTestFixture">
			<template is="dom-template">
				<cosmoz-chart data="[[data]]" axis="[[axis]]" line="[[line]]" config="[[config]]"></cosmoz-chart>
			</template>
		</test-fixture>

		<script type="module">
		import { tap } from '@polymer/iron-test-helpers/mock-interactions.js';
		import { afterNextRender } from '@polymer/polymer/lib/utils/render-status.js';
		import { upgradeDomTemplates } from './helpers/utils.js';

		const nextRender = () => new Promise(resolve => afterNextRender(null, resolve));

		upgradeDomTemplates();

		describe('cosmoz-chart', () => {
			it('draws a simple line chart', async () => {
				const element = fixture('BasicTestFixture', {
					data: {
						columns: [
							['data1', 1, 2, 3]
						]
					}
				});

				await nextRender();

				expect(element.querySelector('.bb-line-data1')).to.exist;
				expect(element.querySelectorAll('circle')).to.have.lengthOf(3);
			});

			it('configures axis', async () => {
				const element = fixture('BasicTestFixture', {
					data: {
						columns: [['data1', 10, 20, 30]]
					},
					axis: {
						x: { show: false},
						y: {
							tick: {
								format(x) {
									return x + '%';
								},
								count: 5
							}
						}
					},
					line: {point: false}
				});

				await nextRender();

				expect(window.getComputedStyle(element.querySelector('.bb-axis-x')).visibility).to.equal('hidden');
				expect(Array.from(element.querySelectorAll('.bb-axis-y .tick')).map(i => i.textContent)).to.deep.equal(['8%', '14%', '20%', '26%', '32%']);
			});

			it('can receive whole configuration object', async () => {
				const element = fixture('BasicTestFixture', {
					data: {
						columns: [['data1', 10, 20, 30]]
					},
					config: {
						axis: {
							x: { show: false }
						}
					}
				});

				await nextRender();

				expect(window.getComputedStyle(element.querySelector('.bb-axis-x')).visibility).to.equal('hidden');
			});

			it('individual prop configurations take precedence over [config]', async () => {
				const element = fixture('BasicTestFixture', {
					data: {
						columns: [['data1', 10, 20, 30]]
					},
					config: {
						axis: {
							x: { show: true }
						}
					},
					axis: {
						x: { show: false }
					},
					line: {}
				});

				await nextRender();

				expect(window.getComputedStyle(element.querySelector('.bb-axis-x')).visibility).to.equal('hidden');
			});

			it('updates the chart when the data changes', async () => {
				const element = fixture('BasicTestFixture', {
					data: {
						columns: [
							['data1', 1, 2, 3]
						]
					}
				});

				await nextRender();

				element.set('data', {
					columns: [
						['data1', 2, 3, 4, 5, 6],
						['data2', 20, 30, 40, 50, 60]
					]
				});

				expect(element.querySelector('.bb-line-data1')).to.exist;
				expect(element.querySelector('.bb-line-data2')).to.exist;
				expect(element.querySelectorAll('circle')).to.have.lengthOf(10);
			});

			it('updates the chart when the config changes', async () => {
				const element = fixture('BasicTestFixture', {
					data: {
						columns: [['data1', 10, 20, 30]]
					}
				});

				await nextRender();

				expect(window.getComputedStyle(element.querySelector('.bb-axis-x')).visibility).to.equal('visible');

				element.set('axis', {
					x: { show: false },
					y: {
						tick: {
							format(x) {
								return x + '%';
							},
							count: 5
						}
					}
				});

				expect(window.getComputedStyle(element.querySelector('.bb-axis-x')).visibility).to.equal('hidden');
				expect(Array.from(element.querySelectorAll('.bb-axis-y .tick')).map(i => i.textContent)).to.deep.equal(['8%', '14%', '20%', '26%', '32%']);
			});

			it('triggers events', () => {
				const onRendered = sinon.spy(),
					onClick = sinon.spy(),
					element = fixture('BasicTestFixture', {
						data: {columns: [['data1', 10, 20, 30]]}
					});

				element.addEventListener('rendered', onRendered);
				element.render();
				expect(onRendered).to.have.been.calledOnce;

				element.addEventListener('dataclick', onClick);
				tap(element.querySelector('.bb-event-rect-1'));
				expect(onClick).to.have.been.calledOnce;
				expect(onClick).to.have.been.calledWithMatch(sinon.match({detail: {d: {x: 1, value: 20}}}));
			});
		});

		</script>
	</body>
</html>
